\documentclass[12pt, letterpaper]{article}
\usepackage{geometry}
\geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=20mm,
 }
\usepackage{graphicx} % Required for inserting images
\usepackage[english,greek]{babel}
\usepackage{mathabx} % Load the mathabx package
\usepackage{subcaption}
\usepackage{dirtytalk}
\newcommand{\en}{\selectlanguage{english}}
\newcommand{\gr}{\selectlanguage{greek}}


\graphicspath{{../plots/}} % specify the path to the images

\title{Εργασία Θεωρίας Δικτύων }
\author{Φίλιππος Ρωσσίδης \\ (ΑΕΜ 10379)}
\date{\today}


\begin{document}
\maketitle

\section{Εισαγωγή}

Στην εργασία αυτή εξετάζουμε την αναγνώρηση κοινοτήτων. Συγκεκριμένα θα 
υλοποιούμε την 
\textlatin{distance quality function}  θα ελέγξουμε κατά πόσο αυτή είναι καλή
επιλογή. 

Οι συναρτήσεις αυτές (\textlatin{quality functions}) δέχονται ως όρισμα έναν
γράφο και μια κατανομή κοινοτήτων και επιστρέφουν μία τιμή. Σκοπώς μας είναι 
να επιστρέφουν υψηλές τιμές για κατανομές που παρουσιάζουν ισχυρή κοινοτική συμπεριφορά,
ώστε να μπορούμε μεγιστοποιώντας αυτή τη συνάρτηση να ανιχνεύσουμε τις κοινότητες.

Θα υλοποιηθεί η συνάρτηση με έναν βέλτιστο ως προς τη ταχύτητα τρόπο, όπως και δύο αλγόριθμοι μεγιστοποίησής της. Θα υλοποιηθούν 
και κάποια \textlatin{benchmarks} ώστε να ποσοτικοποιηθεί η απόδοσή της και θα συγκριθεί με την εδραιωμένη μετρηκότητα \textlatin{modularity}.


\section{Η συνάρτηση \textlatin{distance quality}}

\subsection{Μαθηματικός Ορισμός}

Η συνάρτηση δέχεται σαν όρισμα έναν γράφο και κάποια κατανομή κοινοτήτων.

Ορίζουμε:

\[ D_V(i,j) = \min \{ k:A^k_G (i,j) \neq 0 \} \]
τον πίνακα που περιέχει τις αποστάσεις μεταξύ κάθε δύο κόμβων του γράφου 
$i,j$, όπου $A^k_G(i,j)$ ο πίνακας γειτνίασης του γράφου $G$. υψομένος στην $k$
δύναμη. 

Ορίζουμε επίσης:
\[ D_V(c) = \sum_{i,j \in c} D_V(i,j) \]

Αυτό αποτελεί μέτρο του πόσο στενά συνδεδεμένες είναι μεταξύ τους 
οι κοινότητες. Επιθυμούμε να το συγκρίνουμε με την αναμενώμενη τιμή 
για τυχαίο γράφο.

Για να ορίσουμε τον τυχαίο γράφο επιλέγουμε το γενικευμένο μοντέλο,
όπου συνδέουμε τυχαία ακμές μεταξύ κόμβων, διατηρώντας όμως τον βαθμό τους.


Αν $d_k(v)$ είναι ο $k$ βαθμός του κόμβου $v$, δηλαδή το πλήθος των 
ελάχιστων μονοματιών μήκους $k$ που ξεκινάν από τον $v$ και 
$m_k(G) = \frac{1}{2} \sum_{v \in V (G)} d_k(v)$ το πλήθος 
ελάχιστων μονοπατιών μήκους $k$ στον γράφο $G$, τότε η πιθανότητα δύο κόμβοι
$i,j \in G$ να συνδέονται με ακμή μήκους $k$ είναι:
\[ Pr[i,j,k] = \frac{d_k(i)}{2m_k(G)} \frac{d_k(j)}{2m_k(G)} \]
η αναμενώμενη απόσταση των κόμβων:
\[ \overline{D_V(i,j)} = \sum_{k=1}^{diam(G)} k Pr[i,j,k] \]
όπου $diam(G)$ η διάμετρος του γράφου (μέγιστο ελάχιστο μονοπάτι).

Αν ορίσουμε
\[ \overline{ D_V(c)  } = \frac{1}{2} \sum_{i,j \in c} \overline{ D_V(i,j) }\]
το άθροισμα των αναμενώμενων αποστάσεων των κόμβων στην κοινότητα $C$, 
τότε η συνάρτηση:

\[ Q_d(G,C) = \sum_{c \in C} (\overline{ D_V(c) } - D_V(c))\]
δηλώνει την επιθυμητή σύγκριση του μέτρου στενής σύνδεσης των κοινοτήτων 
$C$ ως προς του τυχαίου γράφου. 

Περιμένουμε οι τιμές της $Q_d$ να είναι υψηλές για ισχυρές δομές κοινοτήτων.


Στην υλοποίηση μου διάλεξα επίσης να τροποποιήσω την συνάρτηση ως εξίς:

\[ D_V(c) = \sum_{i,j \in c} D_V(i,j) \]
\[ \overline{ D_V(c)  } =  \sum_{i,j \in c} \overline{ D_V(i,j) }\]
\[ Q_d(G,C) = \sum_{c \in C} [(1 - \gamma)\overline{ D_V(c) } - \gamma D_V(c) ],  \ \ \ \ \gamma \in (0,1)\]

ώστε για $\gamma = 0.5$ να ισοδυναμεί με τον προϋγούμενο ορισμό, αλλά να έχω 
δυνατότητα να επιλέξω ποιός όρος θα επηρρεάσει περισσότερο.



\subsection{Υλοποίηση}


Χρησιμοποιήθηκε δυναμική προσέγγιση, δηλαδή οι τιμές του αλγορίθμου που χρησιμοποιούνται 
συχνά ($D_V(i,j), \ d_k(i), \ m_G(k), \ Pr[i,j,k],  \ \overline{D_V(i,j)},..$)
υπολογίζονται μία φορά στην αρχή και αποθηκεύονται ώστε να καλούνται σε σταθερό χρόνο στην πορεία. Έτσι γλυτώνουμε τις 
άσκοπες επαναλύψεις. Ειδικότερα στην περίπτωση του συγκεκριμένου αλγορίθμου, αφού 
η συνάρτηση ποιότητας θα υπολογιστεί χιλιάδες φορές για διαφορετικές 
επιλογές κοινοτήτων στην διαδικασία μεγιστοποίησής της, και εφόσον οι μακράν 
πιο αργές διαδικασίες (όπως θα περιγραφτεί παρακάτω) είναι αυτές των 
προαναφερθέντων ποσοτήτων, η διαφορά στο χρόνο εκτέλεσης είναι ραγδαία. 

Όπου είναι δυνατό χρησιμοποιούνται συναρτήσεις της βιβλιοθήκης $networkx$ μιας και 
είναι βελτιστοποιημένες και θα συμβάλουν στην ταχύτητα του κώδικα.

Στην πρώτη φάση του αλγορίθμου υπολογίζονται οι παρακάτω ποσότητες και αποθηκεύονται
για μελλοντική χρήση:
\begin{itemize}
    \item \textbf{διάμετρος του γράφου } 
    
    Χρησιμοποιείται η συνάρτηση της βιβλιοθήκης $networkx: diameter(G)$.
    
    \item  $\mathbf{D_V(i,j)}$
    
    Χρησιμοποιείται η συνάρτηση της βιβλιοθήκης $networkx: all\_pairs\_shortest\_path\_length(G)$,
    η οποία επιστρέφει απευθείας το ζητούμενο, την απόσταση κάθε δύο κόμβων του γράφου
    μεταξύ τους. Τα στοιχεία αποθηκεύονται σε ένα $python \ dict$. Η χρονική
    πολυπλοκότητα της συνάρτησης αυτής είναι $O(|V|^2\log |V| +|V||E|)$ (?), όπου 
    $|V|$ το πλήθος κόμβων του γράφου και $|E|$ το πλήθος των ακμών. 


    \item  $\mathbf{d_k(i)}$ \ και \ $\mathbf{m_G(k)}$
    
    Χρησιμοποιείται η συνάρτηση της βιβλιοθήκης $networkx:$ \\
    $ singe\_source\_shortest\_path\_length(G,source)$, η οποία υπολογίζει για κάποιον
    κόμβο $source$ όλα τα ελάχιστα μονοπάτια που τον έχουν σαν άκρο. Αν υπολογιστούν 
    αυτά τα μονοπάτια για κάθε κόμβο ως $source$ τότε θα έχουμε υπολογίσει
    όλα τα ελάχιστα μονοπάτια του γράφου δύο φορές (μία για $i \rightsquigarrow j$ και 
    μια για $j \rightsquigarrow i$). Η συνάρτηση χρησιμοποιεί την τεχική 
    $Breadth \ First \ Search$, έτσι η χρονική πολυπλοκότητα της είναι 
    $O(|V|+|E|)$

    Τρέχουμε την παραπάνω συνάρτηση για κάθε κόμβο του γράφου ($source$). Στο $dict$ που 
    αυτή επιστρέφει, περιέχονται για κάθε άλλο κόμβο  ($target$) μια λίστα με μήκη από όλα
    τα μονοπάτια που τους ενώνουν ($source \rightsquigarrow target$). Έτσι για κάθε 
    μονοπάτι που βρίσκουμε στη λίστα, έχουμε το μήκος του $k$, 
    αυξάνουμε κατά $1$ τον βαθμό $d_k(source)$ και κατά $0.5$ τη τιμή 
    $m_G(k)$. Χρησιμοποιούμε $0.5$ διότι $m_k(G) = \frac{1}{2} \sum_{v \in V (G)} d_k(v)$
    (μετράμε κάθε μονοπάτι $2$ φορές).

    Η  πολυπλοκότητα της παραπάνω διαδικασίας είναι: $\#add complexity$.

    \item $\mathbf{Pr[i,j,k]}$  \ και \   $\mathbf{\overline{D_V(i,j)}}$
    
    Υπολογίζονται απλά με τους τύπους:
    \[ Pr[i,j,k] = \frac{d_k(i)}{2m_k(G)} \frac{d_k(j)}{2m_k(G)} \]
    \[ \overline{D_V(i,j)} = \sum_{k=1}^{diam(G)} k Pr[i,j,k] \]
    και αποθηκεύονται. 
    
    Συγκεκριμένα οι πίνακες αυτοί είναι συμμετρικοί (αφού 
    $\frac{d_k(i)}{2m_k(G)} \frac{d_k(j)}{2m_k(G)} = \frac{d_k(j)}{2m_k(G)} \frac{d_k(i)}{2m_k(G)}$)
    οπότε οι τιμές αυτές υπολογίζονται μία φορά για κάθε ζευγάρι $i,j$ και προστίθονται
    στο τέλος μία φορά για $i=j$ και δύο για $i \neq j$.
    
    Η χρονική πολυπλοκότητα της παραπάνω διαδικασίας είναι:
    $\#add complexity$.

    

\end{itemize}

Προσοχή χρειάζεται το γεγονός ότι οι παραπάνω διαδικασίες δε μπορούν 
να λειτουργήσουν για μη συνδεδεμένους γράφους. Έτσι υιοθετούμε τη σύμβαση ότι 
δύο μη συνδεδεμές συνεκτικές συνιστώσες δεν μπορούν να βρίσκονται στην ίδια 
κοινότητα. Όποτε διαχωρίζουμε τον γράφο στις συνεκτικές του συνιστώσες και 
τρέχουμε τα παραπάνω για κάθε μία ξεχωριστά. Αυτή η προσέγγιση διατηρεί την 
πολυπλοκότητα ίδια (αφού οι συνεκτικές συνιστώσες διαμερίζουν τον γράφο).

\bigskip

\emph{Συνολική πολυπλοκότητα της πρώτης φάσης: $add complexity$.}

\bigskip

Στη δεύτερη φάση του αλγορίθμου, αφού έχουν αποθηκευτεί τα παραπάνω, 
υπολογίζονται για τις δοσμένες κοινότητες $C$ τα αθροίσματα: 


\[ D_V(C) = \sum_{i,j \in C} D_V(i,j), \qquad \overline{ D_V(C)  } =  \sum_{i,j \in C} \overline{ D_V(i,j) }\]
 για $i,j \in C$, και η τιμή:
\[ Q_d(G,C) = \sum_{c \in C} [(1 - \gamma)\overline{ D_V(C) } - \gamma D_V(C) ]\]


\bigskip

\emph{Συνολική πολυπλοκότητα της δεύτερης φάσης: $O(|V|^2)$.}

\bigskip







\subsubsection{Μια πρώτη ματία στα αποτελέσματα}



\begin{figure}
  \begin{subfigure}{0.5\textwidth}
    \centering 
    \includegraphics[width=0.5\linewidth]{quad_comm_gamma=0.5.pdf}
    \caption{Αποτελέσματα ωμής δύναμης για $\gamma = 0.5$. Κάθε κόμβος βρίσκεται σε δική του κοινότητα.}
    \label{fig:graph8comm}
  \end{subfigure}
  \begin{subfigure}{0.5\textwidth}
    \centering 
    \includegraphics[width=0.7\linewidth]{cluster_4,5gamma=0.02,newman.pdf}
    \caption{Αποτελέσματα αλγορίθμου \textlatin{Newman} για $\gamma = 0.02$. Οι κοινότητες έχουν αναγνωριστεί σωστά.}
    \label{fig:newman4,5}
  \end{subfigure}
  \caption{}
  \label{}
\end{figure}



Για μια πρώτη εικόνα της λειτουργίας της παραπάνω μετρηκής, δοκιμάστηκε τεχνική ωμής δύναμης σε διάφορους γράφους,
για $\gamma = 0.5$ (δηλαδή τον αρχικό ορισμό της).
Ένα παράδειγμα βρίσκεται στο σχήμα \ref{fig:graph8comm}, όπου κάθε κοινότητα χρωματίζεται με δικό της χρώμα. 

Στο σχήμα φαίνονται οι κοινότητες για τις οποίες η τιμή $Q_d$ είναι μέγιστη. Ενώ περιμέναμε για τον γράφο αυτό να επιστραφούν 
δύο κοινότητες των 4 κόμβων, βλέπουμε ότι αυτό δεν συμβαίνει. Συγκεκριμένα για $\gamma = 0.5$ βρέθηκε πειραματικά ότι 
τη μέγιστη τιμή $Q_d$ παίρνουμε πάντα όταν κάθε κόμβος έχει δική του κοινότητα. Σε αυτό θα χρησιμεύσει η τιμή $\gamma$, όπου με την 
αλλαγή της μπορούμε να έχουμε τη επιθυμητή συμπεριφορά.

Παρατίθεται προκαταβολικά στο σχήμα \ref{fig:newman4,5} το αποτέλεσμα του αλγορίθμου \textlatin{Newman} για $\gamma = 0.02$ για να φανεί 
το γεγονός αυτό.















\section{Αλγόριθμοι μεγιστοποίησης του $Q_d$}



\subsection{Πρώτη προσπάθεια άπληστου αλγορίθμου}

Θα περιγράψω τον πρώτο αλγόριθμο που υλοποιήθηκε συνοπτικά, διότι παρότι αντικαταστάθηκε 
από αυτόν του \en Newman, \gr παρουσιάζει κάποια διαφορά στην λογική και τα αποτελέσματα:

\begin{enumerate}
  \item Υπολογίζουμε τις απαραίτητες ποσότητες και τις αποθηκεύουμε \\ ($D_V(i,j), \ d_k(i), \ m_G(k), \ Pr[i,j,k],  \ \overline{D_V(i,j)},diam(G)$).
  \item Αρχικοποιούμε κάθε κόμβο σε δική του κοινότητα.
  \item Για κάθε κόμβο, βρίσκουμε τον γειτονικό του κόμβο στου οποίου την κοινότητα 
  εάν μεταφερθεί θα υπάρχει η μέγιστη μεταβολή στο $Q_d$. Εάν η μεταβολή αυτή είναι θετική,
  τότε τον μεταφέρουμε σε εκείνη την κοινότητα.
  \item Επαναλαμβάνουμε το βήμα 3 μέχρι να μην γίνεται καμία μεταβολή.
\end{enumerate}

Ο αλγορίθμος αυτός δέχεται βελτιστοποίηση, ειδικότερα στο κομμάτι όπου 
υπολογίζει την ποσότητα $Q_d$ για κάθε μεταβολή τον κόμβων σε κοινότητες. 
Ένα μεγάλο μέρος της εξίσωσης $Q_d(G,C) = \sum_{c \in C} [(1 - \gamma)\overline{ D_V(c) } - \gamma D_V(c)]$
παραμένει σταθερό όταν μετακινούμε μόνο έναν κόμβο και κρατάμε τις υπόλοιπες κοινότητες
σταθερές, και το γεγονός αυτό θα εκμεταλευτούμε στη συνέχεια.

Επίσης εδώ τίθεται το ζήτημα της σύγκλισης, εάν ο αλγόριθμος συγκλίνει (εξαρτάται από 
τη τιμή του $\gamma$) και πόσο γρήγορα, το οποίο λύνεται στην συνέχεια.

% αποτελεσματα 

\subsubsection{Απόδοση}

Θα περιγραφτεί εδώ η διαδικασία με την οποία μετρήθηκε η απόδοση του αλγορίθμου, η 
οποία θα χρησιμοποιηθεί και στη συνέχεια για τον αλγόριθμο του \en Newman. \gr

Αρχικά δημιουργείται ένας γράφος ο οποίος αποτελέιται από 4 πλήρεις υπογράφους 
των 5 κόμβων
συνδεδεμένους με μία ακμή σε ένα κύκλο (σχήμα \ref{fig:fullcluster}).
Σε αυτόν τον γράφο περιμένουμε οι κοινότητες να είναι οι τέσσερεις πλήρεις υπογράφοι.


\begin{figure}
  \begin{subfigure}{0.5\textwidth}
    \centering
    \includegraphics[width=0.6\linewidth]{fullcliustergraph.pdf}
    \caption{Αρχικός γράφος \en benchmark \gr}
    \label{fig:fullcluster}
  \end{subfigure}
  \begin{subfigure}{0.5\textwidth}
    \centering
    \includegraphics[width=0.6\linewidth]{iterations=1.pdf}
    \caption{2ο βήμα}
    \label{fig:it1}
  \end{subfigure}
  \caption{}
  \label{}
\end{figure}

\begin{figure}
  \begin{subfigure}{0.5\textwidth}
    \centering
    \includegraphics[width=0.6\linewidth]{iterations=6.pdf}
    \caption{7ο βήμα}
    \label{fig:it6}
  \end{subfigure}
  \begin{subfigure}{0.5\textwidth}
    \centering
    \includegraphics[width=0.6\linewidth]{iterations=15.pdf}
    \caption{16ο βήμα}
    \label{fig:it15}
  \end{subfigure}
  \caption{}
  \label{}
\end{figure}




Έπειτα σε κάθε βήμα αφαιρούμε μία ακμή (τυχαία) από το εσωτερικό των κοινοτήτων και την 
τοποθετούμε στο εξωτερικό τους (δηλαδή να ενώνει δύο διαφορετικές κοινότητες), έτσι 
\say{χαλάμε} σε κάθε βήμα την ποιότητα των κοινοτήτων. Για κάθε βήμα εκτιμούμε με τον 
αλγόριθμό μας τις κοινότητες και τις συγκρίνουμε με τις πραγματικές (\textlatin{Jaccard similarity}).

Στα σχήματα \ref{fig:it1}, \ref{fig:it6}, \ref{fig:it15} βλέπουμε τις εκτιμήσεις του 
αλγορίθμου για βήματα 2,7,16. Βλέπουμε ότι ο αλγόριθμος δεν έχει πολύ καλή απόδοση 
(ειδικά στο βήμα 1 όπου οι κοινότητες θα έπρεπε να είναι ξεκάθαρες), αλλά καταφέρνει 
να ανιχνεύσει κάποια δομή. Στο βήμα 16 όπου η δομή κοινοτήτων δεν είναι καθόλου ξεκάθαρη, 
τα αποτελέσματα είναι αρκετά κακά.

Στο σχήμα \ref{bench1} αποτυπώνουμε την απόδοση (\textlatin{Jaccard similarity})
του αλγορίθμου μας και την αντίστοιχη της \textlatin{modularity} για 20 βήματα.  
Για να εξαλειφθεί ο τυχόν θόρυβος από τις τυχαίες διαδικασίες πάρθηκε ο μέσος όρος 
για 100 ίδια πειράματα. 

Για τη \textlatin{modularity} χρησιμοποιήθηκε η συνάρτηση $greedy\_modularity\_communities$ της 
βιβλιοθήκης \textlatin{networkx}, η οποία λειτουργεί με τον αλγόριθμο των \en Clauset-Newman-Moore \gr 
\cite{Clauset:fastgreedy}\relax.
 
Η \textlatin{distance} έχει σαφώς χειρότερα αποτελέσματα.


\begin{figure}
  \centering
  \includegraphics[width=0.5\linewidth]{benchmark.pdf}
  \caption{Μέση απόδοση με \textlatin{Jaccard similarity} των δύο μετρηκών}
  \label{bench1}
\end{figure}


\subsection{\textlatin{Newman}}

Για καλύτερα αποτελέσματα υλοποιήθηκε ο αλγόριθμος που προτάθηκε από τον \textlatin{Newman} 
\cite{Newman}\relax. 

Ο αγλόριθμος αυτός προτάθηκε για τη μεγιστοποίηση της \en modularity, \gr αλλά μπορεί με τις κατάλληλες τροποποιήσεις να χρησιμοποιηθεί και εδώ.

Ξεκινάμε με μια κοινότητα για κάθε κόμβο αλλά αυτή τη φορά ενώνουμε διαδοχικά \emph{τις κοινότητες} οι οποίες θα έχουν μέγιστη αύξηση του $Q$. Μετά από $|V|-1$ συνδέσεις
θα έχει μείνει μόνο μία κοινότητα, όποτε απαιτούνται το πολύ $|V|-1$ συνδέσεις. 

Στην ταχύτητα βοηθάει η παρατήρηση ότι δε χρειάζεται να υπολογίζεται συνέχεια η τιμή της $Q_d$ αλλά μόνο η διαφορά $\Delta Q_d(c_i,c_j)$ της $Q_d$ αν συνενώσουμε τις 
κοινότητες $c_i$ και $c_j$. 


Αναλυτικά:

Έστω ότι έχω κοινότητες $C = {c_1,..,c_n}$ και συνενώνω τις κοινότητες $c_i,c_j \in C$ ώστε να αποκτήσω
στο επόμενο βήμα κοινότητες $C'$. Έστω επίσης ότι $Q_d$ είναι η τιμή της \textlatin{distance quality}
στις κοινότητες $C$, ενώ $Q_d'$ στις $C'$. 



Για ευκολία συμβολίζω: 
\[ I(c) = [(1 - \gamma)\overline{ D_V(c) } - \gamma D_V(c)] \]
και,
\[ J(i,j) = (1-\gamma) \overline{ D_V(i,j)} - \gamma D_V(i,j) \]
τότε,
\[ Q_d = \sum_{c \in C} I(c) =\sum_{c \in C} \sum_{i,j \in c} J(i,j) \]
Έχουμε:
\[ Q_d  = \sum_{c \in C} I(c) =  \sum_{c \in C \setminus c_i,c_j}[I(c)] + I(c_i) + I(c_j) \Leftrightarrow\]
\[ Q_d = \sum_{c \in C \setminus c_i,c_j}[I(c)] + \sum_{i,j \in c_i}J(i,j) + \sum_{i,j \in c_j}J(i,j)  \]
καi,
\[ Q_d' = \sum_{c \in C'} I(c) =  \sum_{c \in C \setminus c_i,c_j}[I(c)] + I(c_i \cup c_j) \Leftrightarrow \]
\[ Q_d' =  \sum_{c \in C \setminus c_i,c_j}[I(c)] + \sum_{i,j \in c_i \cup c_j} J(i,j) \]



Από τα παραπάνω είναι φανερό ότι:
\[   \Delta Q = Q_d' - Q_d = 2 \sum_{i \in c_i, j \in c_j} J(i,j) \Leftrightarrow \]
\[ \Delta Q = 2 \sum_{i \in c_i, j \in c_j} (1-\gamma) \overline{ D_V(i,j)} - \gamma D_V(i,j) \]

\bigskip

Επιπλέον, όταν ενώνονται δύο κοινότητες $c_i,c_j$, έστω στην $c_j$, τότε για κάθε 
άλλη κοινότητα $c_k$ η τιμή $\Delta Q_{jk}$ μεταβέλεται ως εξίς:

\[ \Delta Q_{jk}' = 2 \sum_{i \in c_i \cup c_j, j \in c_k} J(i,j) = 2 \sum_{i \in c_i, j \in c_k} J(i,j) + 2 \sum_{i \in c_j, j \in c_k} J(i,j) = \Delta Q_{ik} + \Delta Q_{jk}\]


Τώρα είμαστε σε θέση να ορίσουμε τον αλγόριθμο:

Διατηρούμε έναν πίνακα $\Delta Q$ που θα περιέχει για κάθε δύο κοινότητες $c_i,c_j$ 
τη τιμή $\Delta Q_{ij}$. Για την αρχική περίπτωση όπου κάθε κόμβος $v$ έχει δική του 
κοινότητα $c=\{v\}$: 
\begin{equation}   \label{init_dq}
  \Delta Q_{ik} = 2 \cdot [(1-\gamma)\overline{ D_V(c_i,c_j)} - \gamma  D_V(c_i,c_j)   ]
\end{equation}

\begin{enumerate}
  \item Υπολογίζουμε τις απαραίτητες ποσότητες και τις αποθηκεύουμε \\ ($D_V(i,j), \ d_k(i), \ m_G(k), \ Pr[i,j,k],  \ \overline{D_V(i,j)},diam(G)$).
  \item Αρχικοποιούμε κάθε κόμβο σε δική του κοινότητα.
  \item Αρχικοποιούμε τον πίνακα $\Delta Q$ σύμφωνα με την εξίσωση \ref{init_dq}. 
  \item Βρίσκουμε το μέγιστο στοιχείο του πίνακα $\Delta Q$. Αυτό το στοιχείο μας 
  δίνει ποιές κοινότητες θα δώσουν τη μέγιστη διαφορά στην $Q_d$ αν ενωθούν.
  \item Αν το $max \Delta Q_{ij}$ που βρήκαμε είναι θετικό, ενώνουμε τις κοινότητες 
  $c_i, c_j$ στην $c_j$, ανανεώνουμε τα στοιχεία του πίνακα $\Delta Q$ ως εξίς:
  \[ \Delta Q_{jk} = \Delta Q_{kj} = \Delta Q_{ik} + \Delta Q_{jk}, \ \ \ \ \Delta Q_{ik} = \Delta Q_{ki} = -1 \]
  και επιστρέφουμε στο βήμα 4. 
  \item Αν το $max \Delta Q_{ij}$ που βρήκαμε είναι αρνητικό, τότε τερματίζουμε τον αλγόριθμο
  και επιστρέφουμε τις κοινότητες όπως είναι σε αυτό το βήμα. 
\end{enumerate}





Σύμφωνα με την έρευνα των \en Clauset-Newman-Moore \gr \cite{Clauset:fastgreedy},
από το βήμα όπου το $max \Delta Q$ γίνει για πρώτη φορά αρνητικό και μετέπειτα, θα 
συνεχήσει να είναι αρνητικό. Δηλαδή η $Q_d$ θα μειώνεται σταδιακά. Επομένως μόλις φτάσουμε 
σε αυτό το στάδιο μπορούμε να τερματίσουμε τον αλγόριθμο, αφού βρήκαμε το μέγιστο. 

Αυτός ο αλγόριθμος είναι ήδη σημαντικά πιο γρήγορος από τον προϋγούμενο, αφού το εσωτερικό 
της λούπας πλέον απλοποιείται στην εύρεση μέγιστου στοιχείου ενός πίνακα. Τα υπόλοιπα είναι 
μόνο προσθέσεις, αναθέσεις πινάκων και έλεγχοι, όλες διεργασίες 
σταθερού χρόνου. Επίσης στον αλγόριθμο αυτόν δεν χρειάζεται να υπολογιστεί η $Q_d$ 
αναλυτικά, αλλά μόνο τα αρχικά $\Delta Q$ που είναι σημαντικά απλούστερα.

Μια άμεση βελτίωση που θα μπορούσε να γίνει \cite{Clauset:fastgreedy} είναι να τοποθετούμε 
τα $\Delta Q_{ij}$ σε μια σωρό μεγίστων, ώστε να αποφευχθεί το $O(|V|^2)$ της εύρεσης 
μεγίστου στον πίνακα σε $O(log|V|)$. Όμως αυτό δε το υλοποίησα στο πλαίσιο της παρούσης 
εργασίας.




\subsubsection{Απόδοση}


















\selectlanguage{english}
\renewcommand{\refname}{\selectlanguage{greek} Αναφορές}  
\bibliographystyle{plain}
\bibliography{sources.bib}



\end{document}
